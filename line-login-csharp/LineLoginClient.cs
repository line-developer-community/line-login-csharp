using LineDC.Login.Models;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;

namespace LineDC.Login
{
    /// <summary>
    /// Line Login Client
    /// </summary>
    public class LoginClient : ILoginClient
    {
        static private HttpClient _httpClient;

        private HttpClient httpClient
        {
            get
            {
                if (_httpClient == null)
                    _httpClient = new HttpClient();

                return _httpClient;
            }
        }

        /// <summary>
        /// This tells the LINE Platform to return an authorization code.
        /// </summary>
        private string ResponseType = "code";
        /// <summary>
        /// Channel ID. Unique identifier for your channel issued by LINE.
        /// </summary>
        public string ChannelId { get; set; }
        /// <summary>
        /// Channel Secret. Unique secret for your channel issued by LINE.
        /// </summary>
        public string ChannelSecret { get; set; }
        /// <summary>
        /// Callback URL. URL that users are redirected to after authentication and authorization. Must match one of the the callback URLs registered for your channel in the console.
        /// </summary>
        public string RedirectUri { get; set; }
        /// <summary>
        /// A unique alphanumeric string used to prevent cross-site request forgery. This value should be randomly-generated by your application. Cannot be a URL-encoded string.
        /// </summary>
        public string State { get; set; }
        /// <summary>
        /// Permissions granted by the user. You can specify multiple scopes using the URL encoded whitespace character (%20). For more information, see scopes.
        /// </summary>
        public Scope Scope { get; set; }
        /// <summary>
        /// A string used to prevent replay attacks. This value is returned in an ID token.
        /// </summary>
        public string Nonce { get; set; }
        /// <summary>
        /// consent. Used to force the consent screen to be displayed even if the user has already granted all requested permissions.
        /// </summary>
        public bool Prompt { get; set; }
        /// <summary>
        /// Displays an option to add a bot as a friend during login. Set value to either normal or aggressive. For more information, see Linking a bot with your LINE Login channel.
        /// </summary>
        public BotPrompt? BotPrompt { get; set; }

        public LoginClient(string channelId, string channelSecret, string redirectUri, string state, Scope scope, string nonce = null, bool prompt = false, BotPrompt? botPrompt = null)
        {
            ChannelId = channelId;
            ChannelSecret = channelSecret;
            RedirectUri = redirectUri;
            State = state;
            Scope = scope;
            Nonce = nonce;
            Prompt = prompt;
            BotPrompt = BotPrompt;
        }

        /// <summary>
        /// Craft Authorization Uri
        /// https://developers.line.me/en/docs/line-login/web/integrate-line-login/#spy-making-an-authorization-request
        /// </summary>
        /// <returns>Authorization Uri</returns>
        public string GetAuthUri()
        {
            var authUri = $"https://access.line.me/oauth2/v2.1/authorize?response_type={ResponseType}&client_id={ChannelId}&redirect_uri={RedirectUri}&state={State}";
            var scopes = new List<string>();
            if ((Scope & Scope.Profile) == Scope.Profile)
                scopes.Add("profile");
            if ((Scope & Scope.OpenId) == Scope.OpenId)
                scopes.Add("openid");
            if ((Scope & Scope.Email) == Scope.Email)
                scopes.Add("email");
            authUri += $"&scope={string.Join("%20", scopes)}";
            if (!string.IsNullOrEmpty(Nonce))
                authUri += $"&nonce={Nonce}";
            if (Prompt)
                authUri += "&prompt=consent";
            if (BotPrompt != null)
                authUri += $"&bot_prompt={BotPrompt}";

            return authUri;
        }

        /// <summary>
        /// Getting an access token
        /// To get an access token, make an HTTP POST request with the authorization code.Once you have an access token, you can use it to make API calls.The access token is issued at the following endpoint.
        /// https://developers.line.me/en/reference/social-api/#issue-access-token
        /// </summary>
        /// <param name="code">Authorization code</param>
        /// <returns>TokenResponse</returns>
        public async Task<TokenResponse> GetToken(string code)
        {
            var content = new List<KeyValuePair<string, string>>();
            content.Add(new KeyValuePair<string, string>("grant_type", "authorization_code"));
            content.Add(new KeyValuePair<string, string>("code", code));
            content.Add(new KeyValuePair<string, string>("redirect_uri", RedirectUri));
            content.Add(new KeyValuePair<string, string>("client_id", ChannelId));
            content.Add(new KeyValuePair<string, string>("client_secret", ChannelSecret));
            var response = await httpClient.PostAsync(
                $"https://api.line.me/oauth2/v2.1/token",
                new FormUrlEncodedContent(content));
            var tokenResponse = JsonConvert.DeserializeObject<TokenResponse>(await response.Content.ReadAsStringAsync());
            if (!string.IsNullOrEmpty(tokenResponse.IdToken))
                tokenResponse.JWTPayload = GetJWTFromIdToken(tokenResponse.IdToken);

            return tokenResponse;
        }

        /// <summary>
        /// Get user profile
        /// Gets a user's display name, profile image, and status message.
        /// https://developers.line.me/en/reference/social-api/#get-user-profile
        /// </summary>
        /// <param name="accessToken"></param>
        /// <returns>Profile</returns>
        public async Task<Profile> GetProfile(string accessToken)
        {
            httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", accessToken);
            var response = await httpClient.GetAsync("https://api.line.me/v2/profile");
            return JsonConvert.DeserializeObject<Profile>(await response.Content.ReadAsStringAsync());
        }

        /// <summary>
        /// Get friendship status
        /// Gets the friendship status of the user and the bot linked to your LINE Login channel.
        /// Note: Requires an access token with the profile scope. For more information, see Making an authorization request and Scopes.
        /// Note: You must have a bot linked with your channel.For more information, see Linking a bot with your LINE Login channel.
        /// https://developers.line.me/en/reference/social-api/#get-friendship-status
        /// </summary>
        /// <param name="accessToken"></param>
        /// <returns>FriendshipStatusResponse</returns>
        public async Task<FriendshipStatusResponse> GetFriendshipStatus(string accessToken)
        {
            httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", accessToken);
            var response = await httpClient.GetAsync("https://api.line.me/friendship/v1/status");
            return JsonConvert.DeserializeObject<FriendshipStatusResponse>(await response.Content.ReadAsStringAsync());
        }

        /// <summary>
        /// Verifying access tokens
        /// To verify whether an access token is valid, send an HTTP GET request to the following endpoint with the access token in the request body.
        /// https://developers.line.me/en/reference/social-api/#verify-access-token
        /// </summary>
        /// <param name="accessToken">AccessToken</param>
        /// <returns>VerifyResponse</returns>
        public async Task<VerifyResponse> VerifyAccessToken(string accessToken)
        {
            var response = await httpClient.GetAsync($"https://api.line.me/oauth2/v2.1/verify?access_token={accessToken}");
            return JsonConvert.DeserializeObject<VerifyResponse>(await response.Content.ReadAsStringAsync());
        }

        /// <summary>
        /// Refreshing access tokens
        /// To refresh an access token, make an HTTP POST request to the following endpoint with the refresh token in the request body.
        /// https://developers.line.me/en/reference/social-api/#refresh-access-token
        /// </summary>
        /// <param name="refreshToken">RefreshToken</param>
        /// <returns>TokenResponse</returns>
        public async Task<TokenResponse> RefreshAccessToken(string refreshToken)
        {
            var content = new List<KeyValuePair<string, string>>();
            content.Add(new KeyValuePair<string, string>("grant_type", "refresh_token"));
            content.Add(new KeyValuePair<string, string>("refresh_token", refreshToken));
            content.Add(new KeyValuePair<string, string>("client_id", ChannelId));
            content.Add(new KeyValuePair<string, string>("client_secret", ChannelSecret));
            var response = await httpClient.PostAsync(
                $"https://api.line.me/oauth2/v2.1/token",
                new FormUrlEncodedContent(content));
            var tokenResponse = JsonConvert.DeserializeObject<TokenResponse>(await response.Content.ReadAsStringAsync());
            if (!string.IsNullOrEmpty(tokenResponse.IdToken))
                tokenResponse.JWTPayload = GetJWTFromIdToken(tokenResponse.IdToken);

            return tokenResponse;
        }

        /// <summary>
        /// Logging out users (v2)
        /// https://developers.line.me/en/reference/social-api/#revoke-access-token
        /// </summary>
        /// <param name="accessToken">Refresh token string</param>
        /// <returns>True if revoked, otherwise false</returns>
        public async Task<bool> Revoke(string accessToken)
        {
            var content = new List<KeyValuePair<string, string>>();
            content.Add(new KeyValuePair<string, string>("refresh_token", accessToken));
            content.Add(new KeyValuePair<string, string>("client_id", ChannelId));
            content.Add(new KeyValuePair<string, string>("client_secret", ChannelSecret));
            var response = await httpClient.PostAsync(
                $"https://api.line.me/oauth2/v2.1/revoke",
                new FormUrlEncodedContent(content));

            if (response.IsSuccessStatusCode)
                return true;
            else
                return false;
        }

        /// <summary>
        /// ID tokens are JSON web tokens (JWT) with information about the user. The ID token consists of a header, payload, and signature separated by period (.) characters. Each part is a base64url-encoded value. For more information, see the JWT specification.
        /// https://developers.line.me/en/docs/line-login/web/integrate-line-login/#id-tokens
        /// </summary>
        /// <param name="idToken">ID Token</param>
        /// <returns>JWTPayload</returns>
        private JWTPayload GetJWTFromIdToken(string idToken)
        {
            var tokens = idToken.Split('.');
            var header = Encoding.UTF8.GetString(Convert.FromBase64String(GetBase64URLCompatString(tokens[0])));

            var payload = Encoding.UTF8.GetString(Convert.FromBase64String(GetBase64URLCompatString(tokens[1])));
            var signature = Convert.FromBase64String(GetBase64URLCompatString(tokens[2]));
            if (VerifySignature(signature, string.Join(".", tokens[0], tokens[1])))
                return JsonConvert.DeserializeObject<JWTPayload>(payload);
            else
                throw new Exception("invalid signature");
        }

        internal string GetBase64URLCompatString(string content)
        {
            var padding = (4 - content.Length % 4);
            if (padding == 4)
                return content;
            else
                return (content + new string('=', padding)).Replace('-', '+').Replace('_', '/');
        }

        internal bool VerifySignature(byte[] signature, string content)
        {
            try
            {
                var key = Encoding.UTF8.GetBytes(ChannelSecret);
                var body = Encoding.UTF8.GetBytes(content);

                using (HMACSHA256 hmac = new HMACSHA256(key))
                {
                    var hash = hmac.ComputeHash(body, 0, body.Length);
                    return SlowEquals(signature, hash);
                }
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// Compares two-byte arrays in length-constant time. 
        /// This comparison method is used so that password hashes cannot be extracted from on-line systems using a timing attack and then attacked off-line.
        /// <remarks> http://bryanavery.co.uk/cryptography-net-avoiding-timing-attack/#comment-85　</remarks>
        /// </summary>
        private static bool SlowEquals(byte[] a, byte[] b)
        {
            uint diff = (uint)a.Length ^ (uint)b.Length;
            for (int i = 0; i < a.Length && i < b.Length; i++)
                diff |= (uint)(a[i] ^ b[i]);
            return diff == 0;
        }
    }
}
